        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Queryable&lt;T&gt; Class / dart:linq Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="dart:linq" data-type="Queryable&amp;lt;T&amp;gt;">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../dart_linq.html">dart:linq</a> &rsaquo; <a href="../dart_linq/Queryable.html">Queryable&lt;T&gt;</a></div>
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../core.html">core</a></h2><h2><div class="icon-library"></div><a href="../coreimpl.html">coreimpl</a></h2><h2><div class="icon-library"></div><a href="../dart_isolate.html">dart:isolate</a></h2><h2><div class="icon-library"></div><a href="../dart_linq.html">dart:linq</a></h2><ul class="icon">
<li><a href="../dart_linq/Clonable.html"><div class="icon-interface"></div>Clonable&lt;T&gt;</a></li>
<li><div class="icon-class"></div><strong>Queryable&lt;T&gt;</strong></li>
<li><a href="../dart_linq/LinqException.html"><div class="icon-exception"></div>LinqException</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../interceptors.html">interceptors</a></h2><h2><div class="icon-library"></div><a href="../js_helper.html">js_helper</a></h2><h2><div class="icon-library"></div><a href="../Tests.dart.html">Tests.dart</a></h2><h2><div class="icon-library"></div><a href="../unittest.html">unittest</a></h2><h2><div class="icon-library"></div><a href="../uri.html">uri</a></h2><h2><div class="icon-library"></div><a href="../utf.html">utf</a></h2></div>
<div class="content">
        <h2><strong>Queryable&lt;T&gt;</strong>
          Class
        </h2>
        
<div class="doc">
<h2>Primary collection-manipulating class in dart:linq.</h2>
<p>&rarr; methods that return a <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a> return a sequence that contains cloned objects</p>
<p>&rarr; unless otherwise indicated, all results and collections preserve sequence ordering</p>
<p>&rarr; where methods that perform some kind of object comparison, <code>T</code> is required to implement the <a href="http://api.dartlang.org/docs/continuous/dart_core/Comparable.html">Comparable</a> interface</p>
<p>&rarr; some methods require that <code>T</code> implements the <a class="crossref" href="../dart_linq/Clonable.html">Clonable</a> interface</p>
<hr />
<p>This library currently adopts the .NET naming convention instead of Dart's camel-case convention (which may be
revised in the future). All examples in the documentation below use the <a href="../Tests.dart/Pie.html">Pie</a> test class.</p>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-interface"></span><a href="../core/Iterable.html">Iterable</a></span></p>
<h3>Constructors</h3>
<div class="method"><h4 id="Queryable">
new <strong>Queryable</strong>(<a href="../core/Collection.html">Collection</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; source) <a class="anchor-link" href="#Queryable"
              title="Permalink to Queryable&lt;T&gt;.Queryable">#</a></h4>
<div class="doc">
<p>Creates a <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a> sequence from an input that inherits from
<a href="http://api.dartlang.org/dart_core/Collection.html">Collection</a>. It uses this as the data source, preserving the
original object reference.</p>
</div>
</div>
<h3>Static Methods</h3>
<div class="method"><h4 id="Repeat">
<a href="../dart_linq/Queryable.html">Queryable</a> <strong>Repeat</strong>(<a href="../dart_linq/Clonable.html">Clonable</a> element, <a href="../core/int.html">int</a> count) <a class="anchor-link" href="#Repeat"
              title="Permalink to Queryable&lt;T&gt;.Repeat">#</a></h4>
<div class="doc">
<p>Generates a sequence that contains one repeated value, 
<span class="param">element</span>, which must implement the <a class="crossref" href="../dart_linq/Clonable.html">Clonable</a> interface
otherwise an exception will be thrown. 
<span class="param">element</span> will be repeated 
<span class="param">count</span> times in the output sequence.</p>
<hr />
<p>We want to create five pie instances, but all from the same object. Because Dart uses references for objects, we
need to create five new objects. You can do this with:</p>
<pre><code>var templPie = new Pie("Bacon", 6.45);
Queryable.Repeat(templPie, 5).ForEach((p) =&gt; print(p));
</code></pre>
<p>which yields the following output:</p>
<pre><code>Bacon (6.45)
Bacon (6.45)
Bacon (6.45)
Bacon (6.45)
Bacon (6.45)
</code></pre>
<p>Each one of these objects are unique instances because <code>Pie</code> implements the <a class="crossref" href="../dart_linq/Clonable.html">Clonable</a> interface.</p>
</div>
</div>
<h3>Methods</h3>
<div class="method"><h4 id="All">
<a href="../core/bool.html">bool</a> <strong>All</strong>([fn]) <a class="anchor-link" href="#All"
              title="Permalink to Queryable&lt;T&gt;.All">#</a></h4>
<div class="doc">
<h2>Determines whether all elements of a sequence satisfy a condition.</h2>
<p>Say we want to find out if all our pies are not free. We can test this with the <a class="crossref" href="../dart_linq/Queryable.html#Any">Any</a> method like so:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
var str = pies.All((p) =&gt; p.cost &gt; 0) ? "No pies are free" : "There are free pies";
print(str);
</code></pre>
<pre><code>&gt;&gt; No pies are free
</code></pre>
</div>
</div>
<div class="method"><h4 id="Any">
<a href="../core/bool.html">bool</a> <strong>Any</strong>([<a href="../core/Function.html">Function</a> fn]) <a class="anchor-link" href="#Any"
              title="Permalink to Queryable&lt;T&gt;.Any">#</a></h4>
<div class="doc">
<h2>Determines whether any element of a sequence satisfies a condition.</h2>
<p>The following code example demonstrates how to use Any() to determine whether a sequence contains any elements:</p>
<pre><code>Queryable&lt;Pie&gt; pies = new Queryable(Pie.GetTestPies());
var hasPies = pies.Any() ? "are no" : "are";
print("There ${hasPies} pies!");
</code></pre>
<p>which produces the following output:</p>
<pre><code>The are pies!
</code></pre>
<p>You can also determine whether or not a test matches any elements with a predicate:</p>
<pre><code>var hasFreePies = pies.Any((p) =&gt; p.cost &lt;= 0) ? "are" : "are no";
print("There ${hasFreePies} free pies.");
</code></pre>
<p>which produces the following output:</p>
<pre><code>There are no free pies.
</code></pre>
</div>
</div>
<div class="method"><h4 id="AsCollection">
<a href="../core/Collection.html">Collection</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>AsCollection</strong>() <a class="anchor-link" href="#AsCollection"
              title="Permalink to Queryable&lt;T&gt;.AsCollection">#</a></h4>
<div class="doc">
<h2>Returns the current internal collection as a Collection&lt;T>.</h2>
</div>
</div>
<div class="method"><h4 id="Average">
<a href="../core/num.html">num</a> <strong>Average</strong>([fn]) <a class="anchor-link" href="#Average"
              title="Permalink to Queryable&lt;T&gt;.Average">#</a></h4>
<div class="doc">
<h2>Computes the average of a sequence.</h2>
<p>&rarr; a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> may be thrown if the sequence does not contain at least one element</p>
<p>&rarr; a <a href="http://api.dartlang.org/docs/continuous/dart_core/CastException.html">CastException</a> may be thrown if the predicate does not return a <code>num</code></p>
<hr />
<p>The <a class="crossref" href="../dart_linq/Queryable.html#Average">Average</a> method does what it says - computes the average value of a sequence:</p>
<pre><code>var numbers = new Queryable([1,3,2,5,3,6,4]);
print(numbers.Average());
</code></pre>
<pre><code>&gt;&gt; 3.4285714285714284
</code></pre>
<p>However, if your sequence isn't <code>num</code>-typed, you can specify a predicate to select what you would like to average.
In the following example, we're going to find out the average cost of a pie in our pie collection:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
print("Average Cost: \$${pies.Average((p) =&gt; p.cost)}");
</code></pre>
<pre><code>&gt;&gt; Average Cost: $3.5916666666666663
</code></pre>
</div>
</div>
<div class="method"><h4 id="Concat">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Concat</strong>(<a href="../core/Collection.html">Collection</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; other) <a class="anchor-link" href="#Concat"
              title="Permalink to Queryable&lt;T&gt;.Concat">#</a></h4>
<div class="doc">
<h2>Concatenates this sequence instance with another.</h2>
<p>Say we have two sets of pies, one for vegitarians and one for omnivores:</p>
<pre><code>var vegiePies = [ new Pie ("Leek", 4.99), new Pie ("Potato",   2.95) ];
var  omniPies = [ new Pie ("Meat", 5.99), new Pie ("Shepards", 6.99) ];
</code></pre>
<p>We can create new collection called <code>AllPies</code> which encompasses both
collections using the <code>Concat</code> method:</p>
<pre><code>var allPies = new Queryable(vegiePies).Concat(omniPies);
allPies.AsCollection().forEach((p) =&gt; print(p));
</code></pre>
<p>Which yields the result:</p>
<pre><code>Leek (4.99)
Potato (2.95)
Meat (5.99)
Shepards (6.99)
</code></pre>
<p>As you can guess, it appends the second collection to the first.</p>
</div>
</div>
<div class="method"><h4 id="Contains">
<a href="../core/bool.html">bool</a> <strong>Contains</strong>(<a href="../dart_linq/Queryable.html">T</a> value) <a class="anchor-link" href="#Contains"
              title="Permalink to Queryable&lt;T&gt;.Contains">#</a></h4>
<div class="doc">
<h2>Determines whether a sequence contains a specified element by using the default equality comparer.</h2>
<p>&rarr; a <a href="http://api.dartlang.org/docs/continuous/dart_core/CastException.html">CastException</a> will be thrown if <code>T</code>
does not implement the <a href="http://api.dartlang.org/docs/continuous/dart_core/Comparable.html">Comparable</a> interface</p>
<hr />
<p>It's possible, but maybe you've forgotten whether your pie sequence contains a specific pie instance. We can use the
<a class="crossref" href="../dart_linq/Queryable.html#Contains">Contains</a> method to determine whether or not it does contain the specific value</p>
</div>
</div>
<div class="method"><h4 id="Count">
<a href="../core/int.html">int</a> <strong>Count</strong>([<a href="../core/Function.html">Function</a> fn]) <a class="anchor-link" href="#Count"
              title="Permalink to Queryable&lt;T&gt;.Count">#</a></h4>
<div class="doc">
<h2>Returns the number of elements in a sequence.</h2>
</div>
</div>
<div class="method"><h4 id="Distinct">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Distinct</strong>() <a class="anchor-link" href="#Distinct"
              title="Permalink to Queryable&lt;T&gt;.Distinct">#</a></h4>
<div class="doc">
<h2>Returns distinct elements from a sequence.</h2>
<p>We have our pie list, but let's say we add a duplicate Lemon pie to our collection:</p>
<pre><code>var pieList = new List.from(Pie.GetTestPies() as Iterable&lt;Pie&gt;);
pieList.add(new Pie("Lemon", 0.99));
var pies = new Queryable(pieList);
</code></pre>
<p>We know that there are now two duplicate Lemon pies in our <code>pies</code> sequence, but we can use the <a class="crossref" href="../dart_linq/Queryable.html#Distinct">Distinct</a> method to
remove the duplicates from the collection:</p>
<pre><code>pies.Distinct()
    .ForEach((p) =&gt; print(p));
</code></pre>
<pre><code>&gt;&gt; Apple (3.29)
&gt;&gt; Cherry (4.29)
&gt;&gt; Lemon (0.99)
&gt;&gt; Blueberry (4.29)
&gt;&gt; Meat (5.7)
&gt;&gt; Meat (2.99)
</code></pre>
<p>Because <a class="crossref" href="../dart_linq/Queryable.html#Distinct">Distinct</a> uses the default comparer for <code>Pie</code> which compares two pies as strings, it sees <code>Meat (5.7)</code> and
<code>Meat (2.99)</code> as two distinct elements.</p>
</div>
</div>
<div class="method"><h4 id="ElementAt">
<a href="../dart_linq/Queryable.html">T</a> <strong>ElementAt</strong>(<a href="../core/int.html">int</a> n) <a class="anchor-link" href="#ElementAt"
              title="Permalink to Queryable&lt;T&gt;.ElementAt">#</a></h4>
<div class="doc">
<h2>Returns the element at a specified index in a sequence.</h2>
</div>
</div>
<div class="method"><h4 id="ElementAtOrDefault">
<a href="../dart_linq/Queryable.html">T</a> <strong>ElementAtOrDefault</strong>(<a href="../core/int.html">int</a> n) <a class="anchor-link" href="#ElementAtOrDefault"
              title="Permalink to Queryable&lt;T&gt;.ElementAtOrDefault">#</a></h4>
<div class="doc">
<h2>Returns the element at a specified index in a sequence or default.</h2>
</div>
</div>
<div class="method"><h4 id="Except">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Except</strong>(<a href="../core/Collection.html">Collection</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; other) <a class="anchor-link" href="#Except"
              title="Permalink to Queryable&lt;T&gt;.Except">#</a></h4>
<div class="doc">
<h2>Produces the set difference of two sequences by using the default equality comparer to compare values.</h2>
<p>Returns the current sequence except the elements specified in the input collection. The generic type of the
sequences <code>T</code> must implement the <a href="http://api.dartlang.org/dart_core/Comparable.html">Comparable</a> interface.</p>
<hr />
<p>So this method can be thought of as the opposite of the <code>Concat</code> method:
return all the elements except the ones we specify. Say we have our
complete pie collection and we want to remove the berry flavored pies:</p>
<pre><code>var   allPies = Pie.GetTestPies();
var berryPies = [ new Pie("Cherry", 4.29), new Pie("Blueberry", 4.29) ];
</code></pre>
<p>With the <code>Except</code> operation we can, you guessed it, grab all the pies except those specified in <code>berryPies</code>:</p>
<pre><code>allPies.Except(berryPies)
       .ForEach((p) =&gt; print(p));
</code></pre>
<pre><code>&gt;&gt; Apple (3.29)
&gt;&gt; Lemon (0.99)
&gt;&gt; Meat (5.7)
&gt;&gt; Meat (2.99)
</code></pre>
</div>
</div>
<div class="method"><h4 id="First">
<a href="../dart_linq/Queryable.html">T</a> <strong>First</strong>([fn]) <a class="anchor-link" href="#First"
              title="Permalink to Queryable&lt;T&gt;.First">#</a></h4>
<div class="doc">
<h2>Returns the first element or the first element in a sequence that satisfies a specified condition.</h2>
<p>&rarr; a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> will be thrown if the predicate passed in does not match an element, or the sequence contains no elements</p>
<hr />
<p>We can grab the first pie in the sequence thusly:</p>
<pre><code>var allPies = new Queryable(Pie.GetTestPies());
print(allPies.First());
</code></pre>
<pre><code>&gt;&gt; Apple (3.29)
</code></pre>
<p>Say we want to get the first pie in the sequence that costs more than $5. We can do this by supplying a predicate
which returns a boolean result:</p>
<pre><code>print(allPies.First((p) =&gt; p.cost &gt; 5));
</code></pre>
<pre><code>&gt;&gt; Meat (5.7)
</code></pre>
</div>
</div>
<div class="method"><h4 id="FirstOrDefault">
<a href="../dart_linq/Queryable.html">T</a> <strong>FirstOrDefault</strong>([fn]) <a class="anchor-link" href="#FirstOrDefault"
              title="Permalink to Queryable&lt;T&gt;.FirstOrDefault">#</a></h4>
<div class="doc">
<h2>Returns the first element of a sequence, or a default value if the sequence contains no elements.</h2>
<p>This method is just like <a class="crossref" href="../dart_linq/Queryable.html#First">First</a>, however if the sequence is empty or the predicate does not match an element in the
sequence, a null value will be returned instead of a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> being thrown.</p>
</div>
</div>
<div class="method"><h4 id="ForEach">
void <strong>ForEach</strong>(<a href="../core/Function.html">Function</a> fn) <a class="anchor-link" href="#ForEach"
              title="Permalink to Queryable&lt;T&gt;.ForEach">#</a></h4>
<div class="doc">

</div>
</div>
<div class="method"><h4 id="Intersect">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Intersect</strong>(<a href="../core/Collection.html">Collection</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; other) <a class="anchor-link" href="#Intersect"
              title="Permalink to Queryable&lt;T&gt;.Intersect">#</a></h4>
<div class="doc">
<h2>Produces the set intersection of two sequences by using the default equality comparer to compare values.</h2>
<p>We have our list of pies, but perhaps we want to find out from another bakery what the overlap between what they're
selling and what we're selling is. <a class="crossref" href="../dart_linq/Queryable.html#Intersect">Intersect</a> allows us to do that. For example, we have our list of pies:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
</code></pre>
<p>we create a second collection with the competitor's pies:</p>
<pre><code>var otherPies = new List.from([
  new Pie("Raspberry", 4.3),
  new Pie("Cherry", 4.29),
  new Pie("Gooseberry", 3.19),
  new Pie("Blueberry", 4.29),
  new Pie("Mulberry", 1.99)
]);
</code></pre>
<p>We then ask for the <em>intersection</em> of <code>pies</code> with <code>otherPies</code> to find out what both of us are selling:</p>
<pre><code>pies.Intersect(otherPies)
    .ForEach((p) =&gt; print(p));
</code></pre>
<pre><code>&gt;&gt; Cherry (4.29)
&gt;&gt; Blueberry (4.29)
</code></pre>
<p>Remember that this is using the comparer defined in <code>Pie</code> which uses both the name and cost to determine if two
objects represent the same value.</p>
</div>
</div>
<div class="method"><h4 id="Last">
<a href="../dart_linq/Queryable.html">T</a> <strong>Last</strong>([fn]) <a class="anchor-link" href="#Last"
              title="Permalink to Queryable&lt;T&gt;.Last">#</a></h4>
<div class="doc">
<h2>Returns the last element of a sequence or the last element of a sequence that satisfies a specified condition.</h2>
<p>&rarr; a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> will be thrown if the sequence contains no elements or the provided predicate fails to match any elements</p>
<hr />
<p>The <a class="crossref" href="../dart_linq/Queryable.html#Last">Last</a> method grabs the last element in a <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a>. For example, we can grab the last element of our pie
collection with:</p>
<pre><code>var pies = new Queryable(Pies.GetTestPies());
print(pies.Last());
</code></pre>
<pre><code>&gt;&gt; Meat (2.99)
</code></pre>
<p>We can also use <a class="crossref" href="../dart_linq/Queryable.html#Last">Last</a> to get the last element that matches a predicate passed in. For example, we want to grab all
the pies that are over $4 and return the last one:</p>
<pre><code>print(pies.Last((p) =&gt; p.cost &gt; 4));
</code></pre>
<pre><code>&gt;&gt; Meat (5.7)
</code></pre>
</div>
</div>
<div class="method"><h4 id="LastOrDefault">
<a href="../dart_linq/Queryable.html">T</a> <strong>LastOrDefault</strong>([fn]) <a class="anchor-link" href="#LastOrDefault"
              title="Permalink to Queryable&lt;T&gt;.LastOrDefault">#</a></h4>
<div class="doc">

</div>
</div>
<div class="method"><h4 id="Max">
<a href="../core/num.html">num</a> <strong>Max</strong>([fn]) <a class="anchor-link" href="#Max"
              title="Permalink to Queryable&lt;T&gt;.Max">#</a></h4>
<div class="doc">
<h2>Returns the maximum value in a sequence.</h2>
<p>&rarr; a <a href="http://api.dartlang.org/docs/continuous/dart_core/CastException.html">CastException</a> will be thrown if
<code>T</code> is not a <code>num</code> or if a predicate is provided, the predicate does not return a <code>num</code></p>
<p>&rarr; a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> will be thrown if the sequence contains zero elements</p>
<hr />
<p>We can use the <a class="crossref" href="../dart_linq/Queryable.html#Max">Max</a> method to find the maximum value in a <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a> that contains some numbers:</p>
<pre><code>var numbers = new Queryable([1,3,2,5,3,6,4]);
print(numbers.Max());
</code></pre>
<pre><code>&gt;&gt; 6
</code></pre>
<p>We can also pass in a predicate which returns a <code>num</code> to select the maximum if <code>T</code> is not a <code>num</code>-typed collection.
For example, let's find out the most costly pie in our pie collection:</p>
<pre><code>var pies = new Queryable(Pies.GetTestPies());
print(pies.Max((p) =&gt; p.cost));
</code></pre>
<pre><code>&gt;&gt; 5.7
</code></pre>
</div>
</div>
<div class="method"><h4 id="Min">
<a href="../core/num.html">num</a> <strong>Min</strong>([fn]) <a class="anchor-link" href="#Min"
              title="Permalink to Queryable&lt;T&gt;.Min">#</a></h4>
<div class="doc">
<h2>Returns the minimum value in a sequence.</h2>
<p>&rarr; a <a href="http://api.dartlang.org/docs/continuous/dart_core/CastException.html">CastException</a> will be thrown if
<code>T</code> is not a <code>num</code> or if a predicate is provided, the predicate does not return a <code>num</code></p>
<p>&rarr; a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> will be thrown if the sequence contains zero elements</p>
<hr />
<p>We can use the <a class="crossref" href="../dart_linq/Queryable.html#Min">Min</a> method to find the minimum value in a <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a> that contains some numbers:</p>
<pre><code>var numbers = new Queryable([1,3,2,5,3,6,4]);
print(numbers.Min());
</code></pre>
<pre><code>&gt;&gt; 1
</code></pre>
<p>We can also pass in a predicate which returns a <code>num</code> to select the maximum if <code>T</code> is not a <code>num</code>-typed collection.
For example, let's find out the most costly pie in our pie collection:</p>
<pre><code>var pies = new Queryable(Pies.GetTestPies());
print(pies.Min((p) =&gt; p.cost));
</code></pre>
<pre><code>&gt;&gt; 0.99
</code></pre>
</div>
</div>
<div class="method"><h4 id="OrderBy">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>OrderBy</strong>(fn) <a class="anchor-link" href="#OrderBy"
              title="Permalink to Queryable&lt;T&gt;.OrderBy">#</a></h4>
<div class="doc">
<h2>Sorts the elements of a sequence in ascending order according to a comparison function.</h2>
<p>In the following example, we want to take our collection of pies and order them from cheapest to most expensive
using a comparison predicate:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
pies.OrderBy((p,q) =&gt; p.name.compareTo(q.name))
    .ForEach((i) =&gt; print(i));
</code></pre>
<pre><code>&gt;&gt; Lemon (0.99)
&gt;&gt; Meat (2.99)
&gt;&gt; Apple (3.29)
&gt;&gt; Cherry (4.29)
&gt;&gt; Blueberry (4.29)
&gt;&gt; Meat (5.7)
</code></pre>
</div>
</div>
<div class="method"><h4 id="OrderByDescending">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>OrderByDescending</strong>(<a href="../core/Function.html">Function</a> fn) <a class="anchor-link" href="#OrderByDescending"
              title="Permalink to Queryable&lt;T&gt;.OrderByDescending">#</a></h4>
<div class="doc">
<p>Orders a sequence in descending order according to the provided input
function. This operation is equivalent to:</p>
<pre><code>OrderBy(fn).Reverse();
</code></pre>
<hr />
<p>In the following example, we want to take our collection of pies and order
them in descending order by the name of the pie:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
pies.OrderDescending((p,q) =&gt; p.name.compareTo(q.name))
    .ForEach((i) =&gt; print(i));
</code></pre>
<p>which yields the result:</p>
<pre><code>Meat (2.99)
Meat (5.7)
Lemon (0.99)
Cherry (4.29)
Blueberry (4.29)
Apple (3.29)
</code></pre>
</div>
</div>
<div class="method"><h4 id="Reverse">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Reverse</strong>() <a class="anchor-link" href="#Reverse"
              title="Permalink to Queryable&lt;T&gt;.Reverse">#</a></h4>
<div class="doc">
<p>Inverts the order of the elements in a sequence.</p>
</div>
</div>
<div class="method"><h4 id="Select">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../core/Object.html">Object</a>&gt; <strong>Select</strong>(fn) <a class="anchor-link" href="#Select"
              title="Permalink to Queryable&lt;T&gt;.Select">#</a></h4>
<div class="doc">
<h2>Projects each element of a sequence into a new form.</h2>
<p>Say we want to create some strings for a website that shows all the pies and their costs. We could iterate over
the collection, or we could create a new representation of a pie using the <a class="crossref" href="../dart_linq/Queryable.html#Select">Select</a> method:</p>
<pre><code>Queryable&lt;Pie&gt; pies = new Queryable(Pie.GetTestPies());
pies.Select((p) =&gt; "Item: ${p.name}\tCost: \$${p.cost}")
    .ForEach((p) =&gt; print(p));
</code></pre>
<p>So what we're doing is passing in a function that takes a pie (p) and returns a formatted string. For every item
in the <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a>, we apply this function and stash the result, returning it in the output. After we get the
<em>projection</em> back from the <a class="crossref" href="../dart_linq/Queryable.html#Select">Select</a> method, we iterate over it with the <a class="crossref" href="../dart_linq/Queryable.html#ForEach">ForEach</a> method which prints the projected
<code>Pie</code> representation:</p>
<pre><code>&gt;&gt; Item: Apple     Cost: $3.29
&gt;&gt; Item: Cherry    Cost: $4.29
&gt;&gt; Item: Lemon     Cost: $0.99
&gt;&gt; Item: Blueberry Cost: $4.29
&gt;&gt; Item: Meat      Cost: $5.7
&gt;&gt; Item: Meat      Cost: $2.99
</code></pre>
</div>
</div>
<div class="method"><h4 id="Single">
<a href="../dart_linq/Queryable.html">T</a> <strong>Single</strong>(fn) <a class="anchor-link" href="#Single"
              title="Permalink to Queryable&lt;T&gt;.Single">#</a></h4>
<div class="doc">
<h2>Returns the only element of a sequence or the only element that matches a predicate</h2>
<p>&rarr; a <a class="crossref" href="../dart_linq/LinqException.html">LinqException</a> will be thrown if there is not exactly one element in the sequence or only one element that
matches the predicate 
<span class="param">fn</span></p>
<hr />
<p>While it goes without saying that a predicate-less call to <a class="crossref" href="../dart_linq/Queryable.html#Single">Single</a> will return the element, <a class="crossref" href="../dart_linq/Queryable.html#Single">Single</a> is great for
pulling unique items out of a collection. For example, let's grab the object associated with an Apple pie:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
print(pies.Single((p) =&gt; p.name == "Apple"));
</code></pre>
<pre><code>&gt;&gt; Apple (3.29)
</code></pre>
</div>
</div>
<div class="method"><h4 id="SingleOrDefault">
<a href="../dart_linq/Queryable.html">T</a> <strong>SingleOrDefault</strong>(fn) <a class="anchor-link" href="#SingleOrDefault"
              title="Permalink to Queryable&lt;T&gt;.SingleOrDefault">#</a></h4>
<div class="doc">
<h2>Returns the only element of a sequence or default, or the only element that matches a predicate or default</h2>
<p><a class="crossref" href="../dart_linq/Queryable.html#SingleOrDefault">SingleOrDefault</a> is exactly the same as <a class="crossref" href="../dart_linq/Queryable.html#Single">Single</a>, however instead of throwing an exception it returns a default
value (<code>null</code>).</p>
</div>
</div>
<div class="method"><h4 id="Skip">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Skip</strong>(<a href="../core/int.html">int</a> count) <a class="anchor-link" href="#Skip"
              title="Permalink to Queryable&lt;T&gt;.Skip">#</a></h4>
<div class="doc">
<h2>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</h2><ul><li>If 
<span class="param">count</span> is greater than the size of the sequence, a new <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a> of zero elements will be returned</li><li>If 
<span class="param">count</span> is less than or equal to zero, a new <a class="crossref" href="../dart_linq/Queryable.html#new:Queryable">Queryable</a> with all the elements of the current instance will be returned</li></ul>
<hr />
<p>We want to grab all the pies, but not the first two. We can do this using the <a class="crossref" href="../dart_linq/Queryable.html#Skip">Skip</a> method:</p>
<pre><code>var pies = new Queryable(Pie.GetTestPies());
pies.Skip(2).ForEach((p) =&gt; print(p));
</code></pre>
<p>which outputs:</p>
<pre><code>Lemon (0.99)
Blueberry (4.29)
Meat (5.7)
Meat (2.99)
</code></pre>
</div>
</div>
<div class="method"><h4 id="Take">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Take</strong>(<a href="../core/int.html">int</a> count) <a class="anchor-link" href="#Take"
              title="Permalink to Queryable&lt;T&gt;.Take">#</a></h4>
<div class="doc">
<p>Returns a specified number of contiguous elements from the start of a sequence.</p>
</div>
</div>
<div class="method"><h4 id="ToList">
<a href="../core/List.html">List</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>ToList</strong>() <a class="anchor-link" href="#ToList"
              title="Permalink to Queryable&lt;T&gt;.ToList">#</a></h4>
<div class="doc">
<p>Returns this sequence as a new List&lt;T></p>
</div>
</div>
<div class="method"><h4 id="Where">
<a href="../dart_linq/Queryable.html">Queryable</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>Where</strong>(<a href="../core/Function.html">Function</a> fn) <a class="anchor-link" href="#Where"
              title="Permalink to Queryable&lt;T&gt;.Where">#</a></h4>
<div class="doc">
<h2>Filters a sequence of values based on a predicate.</h2>
</div>
</div>
<div class="method"><h4 id="iterator">
<a href="../core/Iterator.html">Iterator</a>&lt;<a href="../dart_linq/Queryable.html">T</a>&gt; <strong>iterator</strong>() <a class="anchor-link" href="#iterator"
              title="Permalink to Queryable&lt;T&gt;.iterator">#</a></h4>
<div class="doc">
<p>Returns the underlying data source's iterator.</p>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
