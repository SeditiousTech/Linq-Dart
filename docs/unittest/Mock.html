        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Mock Class / unittest Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="unittest" data-type="Mock">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../unittest.html">unittest</a> &rsaquo; <a href="../unittest/Mock.html">Mock</a></div>
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Mock</strong>
          Class
        </h2>
        
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#new:Mock">Mock</a> is the base class for all mocked objects, with
support for basic mocking.</p>
<p>To create a mock objects for some class T, create a new class using:</p>
<pre><code>class MockT extends Mock implements T {};
</code></pre>
<p>Then specify the behavior of the Mock for different methods using
<a class="crossref" href="../unittest/Mock.html#when">when</a> (to select the method and parameters) and <code>thenReturn</code>,
<code>alwaysReturn</code>, <code>thenThrow</code>, <code>alwaysThrow</code>, <code>thenCall</code> or <code>alwaysCall</code>.
<code>thenReturn</code>, <code>thenThrow</code> and <code>thenCall</code> are one-shot so you would
typically call these more than once to specify a sequence of actions;
this can be done with chained calls, e.g.:</p>
<pre><code> m.when(callsTo('foo')).
     thenReturn(0).thenReturn(1).thenReturn(2);
</code></pre>
<p><code>thenCall</code> and <code>alwaysCall</code> allow you to proxy mocked methods, chaining
to some other implementation. This provides a way to implement 'spies'.</p>
<p>You can then use the mock object. Once you are done, to verify the
behavior, use <a class="crossref" href="../unittest/Mock.html#getLogs">getLogs</a> to extract a relevant subset of method call
logs and apply <code>Matchers</code> to these through calling <code>verify</code>.</p>
<p>A Mock can be given a name when constructed. In this case instead of
keeping its own log, it uses a shared log. This can be useful to get an
audit trail of interleaved behavior. It is the responsibility of the user
to ensure that mock names, if used, are unique.</p>
<p>Limitations:
- only positional parameters are supported (up to 10);
- to mock getters you will need to include parentheses in the call</p>
<pre><code>  (e.g. m.length() will work but not m.length).
</code></pre>
<p>Here is a simple example:</p>
<pre><code>class MockList extends Mock implements List {};
</code></pre>
<pre><code>List m = new MockList();
m.when(callsTo('add', anything)).alwaysReturn(0);
</code></pre>
<pre><code>m.add('foo');
m.add('bar');
</code></pre>
<pre><code>getLogs(m, callsTo('add', anything)).verify(happenedExactly(2));
getLogs(m, callsTo('add', 'foo')).verify(happenedOnce);
getLogs(m, callsTo('add', 'isNull)).verify(neverHappened);
</code></pre>
<p>Note that we don't need to provide argument matchers for all arguments,
but we do need to provide arguments for all matchers. So this is allowed:</p>
<pre><code>m.when(callsTo('add')).alwaysReturn(0);
m.add(1, 2);
</code></pre>
<p>But this is not allowed and will throw an exception:</p>
<pre><code>m.when(callsTo('add', anything, anything)).alwaysReturn(0);
m.add(1);
</code></pre>
<p>Here is a way to implement a 'spy', which is where we log the call
but then hand it off to some other function, which is the same
method in a real instance of the class being mocked:</p>
<pre><code>class Foo {
  bar(a, b, c) =&gt; a + b + c;
}
</code></pre>
<pre><code>class MockFoo extends Mock implements Foo {
  Foo real;
  MockFoo() {
    real = new Foo();
    this.when(callsTo('bar')).alwaysCall(real.bar);
  }
}
</code></pre>
</div>
<h3>Constructors</h3>
<div class="method"><h4 id="Mock">
new <strong>Mock</strong>.custom([name, log, throwIfNoBehavior, enableLogging]) <a class="anchor-link" href="#Mock"
              title="Permalink to Mock.Mock">#</a></h4>
<div class="doc">
<p>This constructor makes a mock that has a 
<span class="param">name</span> and possibly uses
a shared 
<span class="param">log</span>. If 
<span class="param">throwIfNoBehavior</span> is true, any calls to methods
that have no defined behaviors will throw an exception; otherwise they
will be allowed and logged (but will not do anything).
If 
<span class="param">enableLogging</span> is false, no logging will be done initially (whether
or not a 
<span class="param">log</span> is supplied), but <a class="crossref" href="../unittest/Mock.html#logging">logging</a> can be set to true later.</p>
</div>
</div>
<div class="method"><h4 id="Mock">
new <strong>Mock</strong>() <a class="anchor-link" href="#Mock"
              title="Permalink to Mock.Mock">#</a></h4>
<div class="doc">
<p>Default constructor. Unknown method calls are allowed and logged,
the mock has no name, and has its own log.</p>
</div>
</div>
<h3>Methods</h3>
<div class="method"><h4 id="getLogs">
<a href="../unittest/LogEntryList.html">LogEntryList</a> <strong>getLogs</strong>([<a href="../unittest/CallMatcher.html">CallMatcher</a> logFilter, <a href="../unittest/Matcher.html">Matcher</a> actionMatcher, <a href="../core/bool.html">bool</a> destructive]) <a class="anchor-link" href="#getLogs"
              title="Permalink to Mock.getLogs">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#getLogs">getLogs</a> extracts all calls from the call log that match the
[logFilter] [CallMatcher], and returns the matching list of
<a class="crossref" href="../unittest/LogEntry.html">LogEntry</a>s. If 
<span class="param">destructive</span> is false (the default) the matching
calls are left in the log, else they are removed. Removal allows
us to verify a set of interactions and then verify that there are
no other interactions left. 
<span class="param">actionMatcher</span> can be used to further
restrict the returned logs based on the action the mock performed.</p>
<p>Typical usage:</p>
<pre><code>getLogs(callsTo(...)).verify(...);
</code></pre>
</div>
</div>
<div class="method"><h4 id="logging">
<a href="../core/bool.html">bool</a> <strong>get logging</strong>() <a class="anchor-link" href="#logging"
              title="Permalink to Mock.get logging">#</a></h4>
<div class="doc">

</div>
</div>
<div class="method"><h4 id="logging">
<a href="../core/bool.html">bool</a> <strong>set logging</strong>(<a href="../core/bool.html">bool</a> value) <a class="anchor-link" href="#logging"
              title="Permalink to Mock.set logging">#</a></h4>
<div class="doc">

</div>
</div>
<div class="method"><h4 id="noSuchMethod">
<strong>noSuchMethod</strong>(<a href="../core/String.html">String</a> method, <a href="../core/List.html">List</a> args) <a class="anchor-link" href="#noSuchMethod"
              title="Permalink to Mock.noSuchMethod">#</a></h4>
<div class="doc">
<p>This is the handler for method calls. We loo through the list
of <a class="crossref" href="../unittest/Behavior.html">Behavior</a>s, and find the first match that still has return
values available, and then do the action specified by that
return value. If we find no <a class="crossref" href="../unittest/Behavior.html">Behavior</a> to apply an exception is
thrown.</p>
</div>
</div>
<div class="method"><h4 id="verifyZeroInteractions">
<a href="../core/bool.html">bool</a> <strong>verifyZeroInteractions</strong>() <a class="anchor-link" href="#verifyZeroInteractions"
              title="Permalink to Mock.verifyZeroInteractions">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#verifyZeroInteractions">verifyZeroInteractions</a> returns true if no calls were made</p>
</div>
</div>
<div class="method"><h4 id="when">
<a href="../unittest/Behavior.html">Behavior</a> <strong>when</strong>(<a href="../unittest/CallMatcher.html">CallMatcher</a> logFilter) <a class="anchor-link" href="#when"
              title="Permalink to Mock.when">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../unittest/Mock.html#when">when</a> is used to create a new or extend an existing <a class="crossref" href="../unittest/Behavior.html">Behavior</a>.
A [CallMatcher] [filter] must be supplied, and the <a class="crossref" href="../unittest/Behavior.html">Behavior</a>s for
that signature are returned (being created first if needed).</p>
<p>Typical use case:</p>
<pre><code>mock.when(callsTo(...)).alwaysReturn(...);
</code></pre>
</div>
</div>
<h3>Fields</h3>
<div class="field"><h4 id="log">
<a href="../unittest/LogEntryList.html">LogEntryList</a>         <strong>log</strong> <a class="anchor-link"
            href="#log"
            title="Permalink to Mock.log">#</a>
        </h4>
        <div class="doc">
<p>The <a class="crossref" href="../unittest/Mock.html#log">log</a> of calls made. Only used if <a class="crossref" href="../unittest/Mock.html#name">name</a> is null.</p>
</div>
</div>
<div class="field"><h4 id="name">
final <a href="../core/String.html">String</a>         <strong>name</strong> <a class="anchor-link"
            href="#name"
            title="Permalink to Mock.name">#</a>
        </h4>
        <div class="doc">
<p>The mock name. Needed if the log is shared; optional otherwise.</p>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          <div>This page was generated at 2012-08-01 21:19:36.384</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
